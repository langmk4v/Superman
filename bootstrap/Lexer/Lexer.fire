import Token;
import SourceFile;

namespace firec {
    var lexer_punctuator_table : Array<(string, TokenPunctuators)> = [
        ("+",   TokenPunctuators::Plus),
        ("-",   TokenPunctuators::Minus)
    ];

    class Lexer {
        var source: SourceFile;
        var pos: usize;
        var len: usize;

        fn new(source: SourceFile) -> Lexer {
            return Lexer(source: source, pos: 0, len: source.data.length());
        }

        fn lex(self) -> List<Token> {
            var list : List<Token>;

            // "Option<T>" 型の変数を代入する var 文は、条件式として使用可能。

            while var token = self.tokenize() {
                list.push(*token);
            }

            return list;
        }

        fn tokenize(self) -> Option<Token> {
            self.pass_space();

            if self.is_end() {
                return nullopt;
            }

            var c = self.peek();
            var pos = self.pos;

            var loc = SourceLocation(self.source, pos);

            if c.is_digit() {
                while (!self.is_end() && self.peek().is_digit()) {
                    self.pos++;
                }

                return Token(kind: TokenKind::Integer(), text: self.source.data[pos: self.pos], location: loc);
            }

            // else if ...

            else if var (kind, text) = self.find_punct() {
                return Token(kind: TokenKind::Punctuator(kind), text: text, location: loc);
            }

            Todo(); // error
        }

        fn find_punct(self) -> Option<(string, TokenPunctuators)> {
            for pair in lexer_punctuator_table {
                if self.eat(pair.0) {
                    return pair;
                }
            }

            return nullopt;
        }

        fn match(self, s: string) -> bool {
            return self.pos + s.length() <= self.len && self.source.data[self.pos: self.pos + s.length()] == s;
        }

        fn eat(self, s: string) -> bool {
            if self.match(s) {
                self.pos += s.length();
                return true;
            }
            return false;
        }

        fn pass_space(self) {
            while !self.is_end() && self.peek().is_space() {
                self.pos++;
            }
        }

        fn is_end(self) -> bool {
            return self.pos >= self.len;
        }
    }
}