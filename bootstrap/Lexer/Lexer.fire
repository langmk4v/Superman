import Token;
import SourceFile;

namespace firec {
    class Lexer {
        var source: SourceFile;
        var pos: int;
        var len: int;

        fn new(source: SourceFile) -> Lexer {
            return Lexer(source: source, pos: 0, len: source.data.length());
        }

        fn lex(self) -> List<Token> {
            var list : List<Token>;

            // "Option<T>" 型の変数を代入する var 文は、条件式として使用可能。

            while var token = self.tokenize() {
                list.push(*token);
            }

            return list;
        }

        fn tokenize(self) -> Option<Token> {
            self.pass_space();

            if self.is_end() {
                return nullopt;
            }

            var c = self.peek();
            var pos = self.pos;

            var loc = SourceLocation(source: self.source, position: pos);

            if c.is_digit() {
                while (!self.is_end() && self.peek().is_digit()) {
                    self.pos++;
                }

                var s = self.source.data[pos: self.pos];

                return Token(kind: TokenKind::Integer(s.to_int()), text: s, location: loc);
            }

            // else if ...

            else {
                var found = self.find_punct();

                if found == nullopt {
                    return nullopt;
                }

                return Token(kind: TokenKind::Punctuator((*found).<1>), text: (*found).<0>, location: loc);
            }
        }

        fn find_punct(self) -> Option<(string, TokenPunctuators)> {
            var lexer_punctuator_table : Vec<(string, TokenPunctuators)> = [
                ("+",   TokenPunctuators::Plus),
                ("-",   TokenPunctuators::Minus)
            ];

            for pair in lexer_punctuator_table {
                if self.eat(pair.<0>) {
                    return pair;
                }
            }

            return nullopt;
        }

        fn match(self, s: string) -> bool {
            return self.pos + s.length() <= self.len && self.source.data[self.pos: self.pos + s.length()] == s;
        }

        fn eat(self, s: string) -> bool {
            if self.match(s) {
                self.pos += s.length();
                return true;
            }
            return false;
        }

        fn pass_space(self) {
            while !self.is_end() && self.peek().is_space() {
                self.pos++;
            }
        }

        fn is_end(self) -> bool {
            return self.pos >= self.len;
        }

        fn peek(self) -> char {
            return self.source.data[self.pos];
        }
    }
}